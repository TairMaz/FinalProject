# FinalProject
מגישים: ישי אישון, מתן ברימר, תאיר מזריב

## פירוט על הקבצים המצורפים:

## 1. knapsack.cpp

קובץ התחלתי בשפת c++, הקובץ מכיל אלגוריתם שמחזיר את המשקל המינימלי שניתן לקבל באמצעות תכנות דינמי. האלגוריתם מסוגל לשחזר גם את החפצים שנלקחו.

הרצה על ידי לינוקס (wsl)עם הפקודה:

g++ knapsack.cpp -o knapsack

./knapsack


## 2. flowshop.cpp

קובץ בשפת c++ המכיל אלגוריתם נאיבי לתזמון עבודות בסביבת flow shop. האלגוריתם עובר על כל הפרמוטציות האפשריות לסידור העבודות ועובר על זמני הסיום והמשקלים הסופיים בכל אחת מהפרמוטציות ומחזיר את האופטימלית.

ניתן להכניס את כמות המכונות, זמני עיבוד ומשקלים של העבודות באמצעות הmain או באמצעות קלט מהמשתמש.

לבסוף מוחזר המשקל וסדר העבודות האופטימלי.

בנוסף, עשינו בדיקה באמצעות הנוסחה הבאה למציאת הזמן הסופי של כל עבודה במכונה האחרונה:
<img width="582" height="73" alt="image" src="https://github.com/user-attachments/assets/f5842888-1d41-491c-8a5f-cf9907f76467" />

ההשוואה מופיעה בטבלה אחרי התוצאות, הטבלה משוה בין זמני הסיום של כל עבודה באופן נאיבי ולפי הנוסחה. יש 2 טבלאות, עבור הסידור האופטימלי ועבור הסידור הראשוני 1,2..

הרצה על ידי לינוקס (wsl)עם הפקודה:

g++ flowshop.cpp -o flowshop

./flowshop


## 3. מיטוב סדר עבודות - נאיבי - מעודכן.xlsx

קובץ זה מדגים את בעיית מיטוב סדר העבודות בסביבת Flow Shop, באמצעות חישוב טבלאי ידני ב־Excel.
.
הקובץ כולל 3 דוכמאות שבחנו בהן את הפתרון הנאיבי באופן ידני (אמנם בשתי הדוגמאות האחרונות, עקב ריבוי הסידורים האפשריים לא בחנו את כולם).
עבור כל סדר חישבנו את זמני הסיום ואת המשקל הכולל - פונקציית המטרה.

בקובץ השוואנו בין סדרים שונים לצורך ניתוח ההשפעה של סדר העבודות וכדי להבין את הנוסחא בצורה טובה יותר.
החישובים הידניים עזרו לנו להבין טוב יותר את המשמעות של הבעיה אותה אנו רוצים לפתור ואת מורכבות פתרון יעיל לבעיה בהנתן עבודות רבות ומכונות רבות.


